// =========================================== 
// PSYCHROMETRIC PDF EXPORT
// Export psychrometric calculations to PDF
// with process chains and load calculations
// =========================================== 

import pdfMake from 'pdfmake/build/pdfmake'
import pdfFonts from 'pdfmake/build/vfs_fonts'
import type { TDocumentDefinitions, Content, TableCell } from 'pdfmake/interfaces'
import type {
  PsychrometricSystem,
  PsychrometricPoint,
  PsychrometricProcess,
  StatePointResult,
  ProcessType,
} from '../types/psychrometric'
import { barometricPressureAtAltitude } from '../data/psychrometricConstants'
import { calculateProcess } from '../calculations/psychrometric'

// Initialize fonts
pdfMake.vfs = pdfFonts.vfs

// Process type display names
const PROCESS_NAMES: Record<ProcessType, string> = {
  sensible_heating: 'Sensible Heating',
  sensible_cooling: 'Sensible Cooling',
  evaporative_cooling: 'Evaporative Cooling',
  steam_humidification: 'Steam Humidification',
  dx_dehumidification: 'DX Dehumidification',
  desiccant_dehumidification: 'Desiccant Dehum.',
  mixing: 'Air Mixing',
  oa_ra_mixing: 'OA/RA Mixing',
  space_load: 'Space Load',
  custom: 'Custom',
}

export function exportPsychrometricToPdf(
  system: PsychrometricSystem,
  points: PsychrometricPoint[],
  calculatedPoints: Record<string, StatePointResult>,
  processes?: PsychrometricProcess[]
): void {
  const pressure = barometricPressureAtAltitude(system.altitudeFt)
  const validPoints = points.filter(p => calculatedPoints[p.id])
  
  // Build document
  const docDefinition: TDocumentDefinitions = {
    pageSize: 'LETTER',
    pageOrientation: processes && processes.length > 0 ? 'landscape' : 'portrait',
    pageMargins: [40, 60, 40, 60],
    
    header: {
      columns: [
        { text: 'PSYCHROMETRIC ANALYSIS', style: 'header', margin: [40, 20, 0, 0] },
        { text: new Date().toLocaleDateString(), alignment: 'right', margin: [0, 25, 40, 0], fontSize: 10, color: '#666' },
      ],
    },
    
    footer: (currentPage: number, pageCount: number) => ({
      text: `Page ${currentPage} of ${pageCount} • Generated by HVAC Calculator App`,
      alignment: 'center',
      margin: [0, 20, 0, 0],
      fontSize: 9,
      color: '#999',
    }),
    
    content: [
      // Title
      { text: system.name, style: 'title', margin: [0, 0, 0, 15] },
      
      // Atmospheric Conditions
      { text: 'Atmospheric Conditions', style: 'sectionHeader' },
      {
        columns: [
          { width: '50%', text: `Altitude: ${system.altitudeFt} ft` },
          { width: '50%', text: `Barometric Pressure: ${pressure.toFixed(3)} psia (${(pressure * 29.921 / 14.696).toFixed(2)} in.Hg)` },
        ],
        margin: [0, 5, 0, 15],
      },
      
      // State Points Table
      { text: 'State Points', style: 'sectionHeader', margin: [0, 10, 0, 5] },
      buildPointsTable(validPoints, calculatedPoints),
      
      // HVAC Processes (from stored processes)
      ...(processes && processes.length > 0 
        ? buildProcessesSection(processes, points, calculatedPoints) 
        : []),
      
      // Quick Reference
      { text: 'Quick Reference', style: 'sectionHeader', margin: [0, 20, 0, 5], pageBreak: (processes && processes.length > 3) ? 'before' : undefined },
      buildReferenceTable(),
    ],
    
    styles: {
      header: {
        fontSize: 12,
        bold: true,
        color: '#333',
      },
      title: {
        fontSize: 20,
        bold: true,
        color: '#06b6d4',
      },
      sectionHeader: {
        fontSize: 14,
        bold: true,
        color: '#333',
        margin: [0, 10, 0, 5],
      },
      tableHeader: {
        bold: true,
        fillColor: '#f3f4f6',
        color: '#333',
      },
      chainIndicator: {
        color: '#06b6d4',
        bold: true,
      },
      heatingValue: {
        color: '#ef4444',
      },
      coolingValue: {
        color: '#3b82f6',
      },
    },
    
    defaultStyle: {
      fontSize: 10,
      color: '#374151',
    },
  }
  
  // Generate and download
  const filename = `psychrometric_${system.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.pdf`
  pdfMake.createPdf(docDefinition).download(filename)
}

function buildPointsTable(
  points: PsychrometricPoint[],
  calculatedPoints: Record<string, StatePointResult>
): Content {
  const headers: TableCell[] = [
    { text: 'Point', style: 'tableHeader' },
    { text: 'DB (°F)', style: 'tableHeader', alignment: 'right' },
    { text: 'WB (°F)', style: 'tableHeader', alignment: 'right' },
    { text: 'DP (°F)', style: 'tableHeader', alignment: 'right' },
    { text: 'RH (%)', style: 'tableHeader', alignment: 'right' },
    { text: 'W (gr/lb)', style: 'tableHeader', alignment: 'right' },
    { text: 'h (Btu/lb)', style: 'tableHeader', alignment: 'right' },
    { text: 'v (ft³/lb)', style: 'tableHeader', alignment: 'right' },
  ]
  
  const body: TableCell[][] = [headers]
  
  points.forEach(point => {
    const result = calculatedPoints[point.id]
    if (result) {
      body.push([
        { text: point.pointLabel, bold: true },
        { text: result.dryBulbF.toFixed(1), alignment: 'right' },
        { text: result.wetBulbF.toFixed(1), alignment: 'right' },
        { text: result.dewPointF.toFixed(1), alignment: 'right' },
        { text: result.relativeHumidity.toFixed(1), alignment: 'right' },
        { text: result.humidityRatioGrains.toFixed(1), alignment: 'right' },
        { text: result.enthalpyBtuLb.toFixed(2), alignment: 'right' },
        { text: result.specificVolumeFt3Lb.toFixed(3), alignment: 'right' },
      ])
    }
  })
  
  return {
    table: {
      headerRows: 1,
      widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
      body,
    },
    layout: 'lightHorizontalLines',
    margin: [0, 5, 0, 10],
  }
}

function buildProcessesSection(
  processes: PsychrometricProcess[],
  points: PsychrometricPoint[],
  calculatedPoints: Record<string, StatePointResult>
): Content[] {
  const content: Content[] = [
    { text: 'HVAC Processes', style: 'sectionHeader', margin: [0, 15, 0, 5] },
  ]
  
  // Build process table
  const headers: TableCell[] = [
    { text: '#', style: 'tableHeader', alignment: 'center' },
    { text: 'Process / Label', style: 'tableHeader' },
    { text: 'Description', style: 'tableHeader' },
    { text: 'Type', style: 'tableHeader' },
    { text: 'Start', style: 'tableHeader', alignment: 'center' },
    { text: 'End', style: 'tableHeader', alignment: 'center' },
    { text: 'CFM', style: 'tableHeader', alignment: 'right' },
    { text: 'Total (Btuh)', style: 'tableHeader', alignment: 'right' },
    { text: 'Sensible', style: 'tableHeader', alignment: 'right' },
    { text: 'Latent', style: 'tableHeader', alignment: 'right' },
    { text: 'Tons', style: 'tableHeader', alignment: 'right' },
    { text: 'Moisture', style: 'tableHeader', alignment: 'right' },
    { text: 'SHR', style: 'tableHeader', alignment: 'right' },
  ]
  
  const body: TableCell[][] = [headers]
  
  let totalSensible = 0
  let totalLatent = 0
  let totalLoad = 0
  let totalTons = 0
  let totalMoisture = 0
  
  processes.forEach((process, idx) => {
    const startPoint = process.startPointId ? calculatedPoints[process.startPointId] : null
    const endPoint = process.endPointId ? calculatedPoints[process.endPointId] : null
    const startPt = points.find(p => p.id === process.startPointId)
    const endPt = points.find(p => p.id === process.endPointId)
    
    // Check if chained from previous
    const isChained = idx > 0 && processes[idx - 1].endPointId === process.startPointId
    
    let result = null
    if (startPoint && endPoint && process.cfm > 0) {
      try {
        result = calculateProcess(startPoint, endPoint, process.cfm)
      } catch (e) {
        console.warn('Failed to calculate process:', e)
      }
    }
    
    const isHeating = result && result.sensibleLoadBtuh > 0
    const loadColor = isHeating ? '#ef4444' : '#3b82f6'
    
    body.push([
      { text: isChained ? `⛓ ${idx + 1}` : `${idx + 1}`, alignment: 'center', color: isChained ? '#06b6d4' : undefined },
      { 
        text: process.label ? `${process.name}\n${process.label}` : process.name, 
        fontSize: process.label ? 9 : 10 
      },
      { text: process.description || '', fontSize: 8, color: '#666666' },
      { text: PROCESS_NAMES[process.processType] || process.processType, fontSize: 9 },
      { 
        text: startPt ? `${startPt.pointLabel}\n${startPoint?.dryBulbF.toFixed(0)}°F` : '—', 
        alignment: 'center',
        fontSize: 9,
      },
      { 
        text: endPt ? `${endPt.pointLabel}\n${endPoint?.dryBulbF.toFixed(0)}°F` : '—', 
        alignment: 'center',
        fontSize: 9,
      },
      { text: process.cfm.toLocaleString(), alignment: 'right' },
      { 
        text: result ? Math.abs(result.totalLoadBtuh).toLocaleString() : '—', 
        alignment: 'right',
        color: result ? loadColor : undefined,
      },
      { text: result ? Math.abs(result.sensibleLoadBtuh).toLocaleString() : '—', alignment: 'right' },
      { text: result ? Math.abs(result.latentLoadBtuh).toLocaleString() : '—', alignment: 'right' },
      { text: result ? Math.abs(result.totalLoadTons).toFixed(2) : '—', alignment: 'right', bold: true },
      { 
        text: result ? `${result.moistureLbHr > 0 ? '+' : ''}${result.moistureLbHr.toFixed(2)}` : '—', 
        alignment: 'right',
        color: result && result.moistureLbHr > 0 ? '#8b5cf6' : '#06b6d4',
      },
      { text: result ? `${(result.sensibleHeatRatio * 100).toFixed(0)}%` : '—', alignment: 'right' },
    ])
    
    if (result) {
      totalSensible += result.sensibleLoadBtuh
      totalLatent += result.latentLoadBtuh
      totalLoad += result.totalLoadBtuh
      totalTons += Math.abs(result.totalLoadTons)
      totalMoisture += result.moistureLbHr
    }
  })
  
  // Add totals row
  body.push([
    { text: '', colSpan: 6 },
    {},
    {},
    {},
    {},
    {},
    { text: 'TOTALS:', alignment: 'right', bold: true },
    { text: Math.abs(totalLoad).toLocaleString(), alignment: 'right', bold: true },
    { text: Math.abs(totalSensible).toLocaleString(), alignment: 'right', bold: true },
    { text: Math.abs(totalLatent).toLocaleString(), alignment: 'right', bold: true },
    { text: totalTons.toFixed(2), alignment: 'right', bold: true },
    { 
      text: `${totalMoisture > 0 ? '+' : ''}${totalMoisture.toFixed(2)}`, 
      alignment: 'right', 
      bold: true,
      color: totalMoisture > 0 ? '#8b5cf6' : '#06b6d4',
    },
    { text: '', alignment: 'right' },
  ])
  
  content.push({
    table: {
      headerRows: 1,
      widths: ['auto', 'auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
      body,
    },
    layout: 'lightHorizontalLines',
    margin: [0, 5, 0, 10],
  })
  
  // Add legend
  content.push({
    columns: [
      { text: '⛓ = Chained process', fontSize: 8, color: '#06b6d4' },
      { text: 'Red = Heating | Blue = Cooling', fontSize: 8, color: '#666' },
      { text: 'Violet = Humidify | Cyan = Dehumidify', fontSize: 8, color: '#666' },
    ],
    margin: [0, 5, 0, 10],
  })
  
  return content
}

function buildReferenceTable(): Content {
  return {
    table: {
      widths: ['*', '*'],
      body: [
        [{ text: 'Standard Air Properties', colSpan: 2, style: 'tableHeader' }, {}],
        ['Density', '0.075 lb/ft³'],
        ['Specific Heat (cp)', '0.240 Btu/lb·°F'],
        ['', ''],
        [{ text: 'Heat Transfer Equations', colSpan: 2, style: 'tableHeader' }, {}],
        ['Sensible Heat', 'Qs = 1.08 × CFM × ΔT (Btuh)'],
        ['Total Heat', 'Qt = 4.5 × CFM × Δh (Btuh)'],
        ['Latent Heat', 'QL = 0.68 × CFM × ΔW (Btuh)'],
      ],
    },
    layout: 'lightHorizontalLines',
    margin: [0, 5, 0, 0],
  }
}
